
v ::= "<string>" | <int>

x ::= <identifier>

e :: <event>

ē ::= ∅ | e ē

φ ::= ⊥ | ⊤ | φ ∨ φ | φ ∧ φ | ¬ φ | φ ⇒ φ
    | ◯ φ | ◯ⁿ φ | ☐ ᪲ φ | ☐ᵏ φ | ♢ⁿ φ | φ \|ⁿ φ
    | A
    | ∀x. φ
    | x = v


--------- Satisfiability rules of formulas (assuming a background first-order logic): -----------

┌─────┐
│ē ⊧ φ│
└─────┘

(ē ⊧ ∀x. φ) ⇔ (∀x. (ē ⊧ φ))
(e ē ⊧ ☐ ᪲ φ) ⇔ ((e ē ⊧ φ) ∧ (ē ⊧ ☐ ᪲ φ))
(e ē ⊧ ☐⁰ φ) ⇔ ⊤
(e ē ⊧ ☐¹⁺ᵏ φ) ⇔ ((e ē ⊧ φ) ∧ (ē ⊧ ☐ᵏ φ))
(ē ⊧ ♢⁰ φ)  ⇔ ⊥
(e ē ⊧ ♢¹⁺ᵏ φ) ⇔ ((e ē ⊧ φ) ∨ (ē ⊧ ♢ᵏ φ))
(_ ē ⊧ ◯ φ) ⇔ (ē ⊧ φ)
(ē ⊧ ◯⁰ φ) ⇔ (ē ⊧ φ)
(ē ⊧ ◯¹⁺ᵏ φ) ⇔ (ē ⊧ ◯ (◯ᵏ φ))
(ē ⊧ φ ∨ ψ) ⇔ ((ē ⊧ φ) ∨ (ē ⊧ ψ))
(ē ⊧ φ ∧ ψ) ⇔ ((ē ⊧ φ) ∧ (ē ⊧ ψ))
(ē ⊧ φ ⇒ ψ) ⇔ ((ē ⊧ φ) ⇒ (ē ⊧ ψ))
(ē ⊧ ¬ φ) ⇔ ¬ (ē ⊧ φ)
(ē ⊧ ⊥) ⇔ ⊥
(ē ⊧ ⊤) ⇔ ⊤
(e ē ⊧ φ |⁰ ψ) ⇔ ψ
(e ē ⊧ φ |¹⁺ᵏ ψ) ⇔ ((e ē ⊧ ψ) ∨ (e ē ⊧ φ) ∧ (ē ⊧ φ |ᵏ ψ))
(e _ ⊧ A(p, c̄)) ⇔ c̄ ⊆ props e   if ty e = p
                  ⊥             otherwise

∅ ⊆ P ⇔ ⊤
{x = t} ⊔ c̄ ⊆ P ⇔ t = P(x) ∧ c̄ ⊆ P   if P(x) is defined
                  ⊥                  otherwise




------------- Examples ------------
φ |⁰ ψ = ◯⁰ ψ

φ |¹ ψ = ◯⁰ ψ
       ∨ ◯⁰ φ ∧ ◯¹ ψ

φ |² ψ = ψ ∨ φ ∧ ◯ (◯⁰ ψ ∨ φ ∧ ◯¹ ψ) = ψ ∨ φ ∧ (◯¹ ψ ∨ ◯¹ φ ∧ ◯² ψ)
       = ◯⁰ ψ
       ∨ ◯⁰ φ ∧ ◯¹ ψ
       ∨ ◯⁰ φ ∧ ◯¹ φ ∧ ◯² ψ

φ |³ ψ = ◯⁰ ψ                        (0)
       ∨ ◯⁰ φ ∧ ◯¹ ψ                 (1)
       ∨ ◯⁰ φ ∧ ◯¹ φ ∧ ◯² ψ          (2)
       ∨ ◯⁰ φ ∧ ◯¹ φ ∧ ◯² φ ∧ ◯³ ψ   (3)



Note:
φ |ⁿ ψ ≡ Σⁿₖ₌₀ (☐ᵏ φ ∧ ◯ᵏ ψ)
